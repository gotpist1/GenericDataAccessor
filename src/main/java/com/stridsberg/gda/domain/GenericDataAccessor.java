// {{CopyrightNotice}}
package com.stridsberg.gda.domain;

import java.lang.reflect.Field;
import java.math.BigDecimal;
import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import org.apache.commons.dbutils.DbUtils;
import org.apache.commons.dbutils.QueryRunner;
import org.apache.commons.dbutils.handlers.BeanHandler;
import org.apache.commons.dbutils.handlers.BeanListHandler;
import org.apache.commons.dbutils.handlers.BeanMapHandler;
import org.apache.commons.dbutils.handlers.ColumnListHandler;
import org.apache.commons.dbutils.handlers.ScalarHandler;

import com.ibm.as400.access.AS400JDBCDatabaseMetaData;
import com.ibm.as400.access.AS400JDBCResultSet;
import com.stridsberg.gda.utils.FormatValues;

/**
 * The <code>ASWDataAccessor</code> class
 */
public class GenericDataAccessor {

	private Connection connection;

	private PreparedStatement prpStmt;

	private ResultSet rs;

	// Test method for this Class
	// public static void main(String[] args){
	// try{
	// AS400Connection aswCon =
	// DefaultConnectionHandler.getInstance().getConnection("95");
	// GenericDataAccessor test = new GenericDataAccessor(aswCon);
	// Map<String, Sroprg> map = test.getResultObjectMap("Select * from sroprg
	// where pgprdc = ? or pgprdc = ?", Sroprg.class, "PGIS01", "58186703",
	// "99994");
	// // file.forEach(row -> System.out.println(row.getPgdesc()));
	//
	// map.forEach((k, v) -> System.out.println(k + " " + v.getPgdesc()));
	// aswCon.close();
	// }catch(Exception e){
	// // TODO Auto-generated catch block
	// e.printStackTrace();
	// }
	// }

	/**
	 * Initializes a newly created <code>GenericDataAccessor</code>
	 *
	 * @param aswCon
	 * @throws Exception
	 */
	// public GenericDataAccessor(AS400Connection aswCon) throws Exception{
	// this.connection = aswCon.getConnection();
	// }

	/**
	 * Initializes a newly created <code>GenericDataAccessor</code>
	 *
	 * @param connection
	 * @throws Exception
	 */
	public GenericDataAccessor(Connection connection) throws Exception {
		this.connection = connection;
	}

	/**
	 * Retrieves a list of models from the Database specified by your SQL.
	 * 
	 * @param sql
	 * @param model
	 * @param params
	 * @return
	 */
	public <T> List<T> getResultObjectList(String sql, Class<T> model, Object... params) {
		List<T> objectList = null;
		QueryRunner run = new QueryRunner();
		FormatValues format = new FormatValues();
		boolean hasParams = params != null && params.length > 0 ? true : false;
		try {

			// Use the BeanListHandler implementation to convert all
			// ResultSet rows into a List of model JavaBeans.
			BeanListHandler<T> handler = new BeanListHandler<T>(model);

			// Execute the SQL statement and return the results in a List of
			// model objects generated by the BeanListHandler.
			if (hasParams) {
				objectList = run.query(connection, sql, handler, params);
			} else {
				objectList = run.query(connection, sql, handler);
			}

		} catch (SQLException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}

		return objectList != null ? format.getFormatedList(objectList) : objectList;
	}

	/**
	 * Gets a list of one column results.
	 * 
	 * @param sql
	 * @param params
	 * @return
	 */
	public <T> List<T> getOneColumnListResulst(String sql, Object... params) {
		List<T> objectList = null;
		QueryRunner run = new QueryRunner();
		FormatValues format = new FormatValues();
		boolean hasParams = params != null && params.length > 0 ? true : false;
		try {
			ColumnListHandler<T> handler = new ColumnListHandler<T>();
			if (hasParams) {
				objectList = run.query(connection, sql, handler, params);
			} else {
				objectList = run.query(connection, sql, handler);
			}
		} catch (Exception e) {

		} finally {

		}
		return objectList;
	}

	/**
	 * Gets the result as a Map, with the column value from the column you
	 * provided as key.
	 * 
	 * @param sql
	 * @param model
	 * @param columnAsKey
	 * @param params
	 * @return
	 */
	public <T> Map<String, T> getResultObjectMap(String sql, Class<T> model, String columnAsKey, Object... params) {
		Map<String, T> modelMap = null;
		final Map<String, T> formatedMap = new HashMap<String, T>();
		QueryRunner run = new QueryRunner();
		FormatValues format = new FormatValues();
		boolean hasParams = params != null && params.length > 0 ? true : false;
		BeanMapHandler<String, T> handler = new BeanMapHandler<String, T>(model, columnAsKey);
		try {

			if (hasParams) {
				modelMap = run.query(connection, sql, handler, params);
			} else {
				modelMap = run.query(connection, sql, handler);
			}
			if (modelMap != null)
				modelMap.forEach((k, v) -> {
					formatedMap.put(format.formatValue(k), format.getFormatedObject(v));
				});

		} catch (SQLException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		return formatedMap;

	}

	/**
	 * Retrieves one row from the Database specified by your SQL into a model.
	 * 
	 * @param sql
	 * @param model
	 *            your model class
	 * @param params
	 *            sql parameters
	 * @return Row Object
	 */
	public <T> T getResultObject(String sql, Class<T> model, Object... params) {
		QueryRunner run = new QueryRunner();
		BeanHandler<T> handler = new BeanHandler<T>(model);
		T object = null;
		FormatValues format = new FormatValues();
		try {
			object = run.query(connection, sql, handler, params);
		} catch (SQLException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		return object != null ? format.getFormatedObject(object) : object;

	}

	/**
	 * Gets resultSet from SQL. Remember to close it when you are done.
	 * 
	 * @param sql
	 *            SQL String
	 * @param params
	 *            Parameters if any in SQL string
	 * @return
	 * @throws SQLException
	 */
	public ResultSet getResultSetFromSql(String sql, Object... params) throws SQLException {
		int index = 1;
		boolean hasParameters = params != null && params.length > 0;
		try {
			prpStmt = connection.prepareStatement(sql);
			if (hasParameters)
				for (Object param : params) {
					prpStmt.setObject(index, param);
					index++;
				}
			rs = prpStmt.executeQuery();
		} catch (SQLException e) {
			// TODO Auto-generated catch block
			if (prpStmt != null)
				prpStmt.close();
			if (rs != null)
				rs.close();
			e.printStackTrace();
		}

		return rs;
	}

	/**
	 * Gets one column object from sql query.
	 * 
	 * @param sql
	 * @param params
	 * @return
	 */
	public <T> T getOneColumnResultObject(String sql, Object... params) {
		QueryRunner run = new QueryRunner();
		ScalarHandler<T> handler = new ScalarHandler<T>();

		T object = null;
		try {
			object = run.query(connection, sql, handler, params);
		} catch (SQLException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		return object;
	}

	/**
	 * Inserts one row into the Database with parameters and values from model.
	 * 
	 * @param model
	 *            The model representing the ASW file.
	 * @return
	 * @throws SQLException
	 */
	public int insertWithModel(Object model) throws SQLException {
		ModelToSqlConverter modelConverter = new ModelToSqlConverter(model);
		QueryRunner qryRunner = new QueryRunner();
		int inserts = 1;
		inserts = qryRunner.update(connection,
				"INSERT INTO " + model.getClass().getSimpleName().toUpperCase() + " " + modelConverter.getSqlString(),
				modelConverter.getParams());

		return inserts;
	}

	/**
	 * Insert batch of rows from model list into the Database, to the table from
	 * the provided tableName.
	 * 
	 * @param modelsList
	 *            List of model objects representing the Database table.
	 * @return int Array of inserted rows.
	 * @throws SQLException
	 */
	public <T> int[] insertWithListOfModels(List<T> modelsList, String tableName) throws SQLException {
		ModelToSqlConverter modelConverter = new ModelToSqlConverter(modelsList);
		QueryRunner qryRunner = new QueryRunner();
		int[] inserts = null;

		System.out.println("INSERT INTO " + tableName + " " + modelConverter.getSqlString());
		inserts = qryRunner.batch(connection, "INSERT INTO " + tableName + " " + modelConverter.getSqlString(),
				modelConverter.getMultiValueParams());
		return inserts;
	}

	/**
	 * Insert batch of rows from model list into the Database. The model must
	 * have the same name as the database table.
	 * 
	 * @param modelsList
	 *            List of model objects representing the Database table.
	 * @return int Array of inserted rows.
	 * @throws SQLException
	 */
	public <T> int[] insertWithListOfModels(List<T> modelsList) throws SQLException {
		return insertWithListOfModels(modelsList, modelsList.get(0).getClass().getSimpleName().toUpperCase());
	}

	/**
	 * Inserts row to database.<br>
	 * Replacement parameters must match the order of the SQL.
	 * 
	 * @param model
	 * @param itemOrCrossReference
	 * @return
	 * @throws SQLException
	 */
	public int insertRowToDatabase(String insertSql, Object... params) throws SQLException {
		QueryRunner qryRunner = new QueryRunner();
		int inserts = 1;

		inserts = qryRunner.update(connection, insertSql, params);

		return inserts;
	}

	/**
	 * Updates one specific row in the Database with parameters from model and
	 * presented keys.
	 * 
	 * @param model
	 *            The model representing the Database table.
	 * @param keys
	 *            Which fields selected as keys in the ASW file for update.
	 * @return
	 * @throws SQLException
	 */
	public int updateWithModel(Object model, String... keys) throws SQLException {
		ModelToSqlConverter modelConverter = new ModelToSqlConverter(model, keys);
		QueryRunner qryRunner = new QueryRunner();
		int inserts = 1;
		inserts = qryRunner.update(connection,
				"UPDATE " + model.getClass().getSimpleName().toUpperCase() + " SET " + modelConverter.getSqlString(),
				modelConverter.getParams());

		return inserts;
	}

	/**
	 * Batch update from list of models.
	 * 
	 * @param modelsList
	 *            List of model objects representing the Database table.
	 * @param keys
	 *            Which fields selected as keys in the Database table for
	 *            update.
	 * @return
	 * @throws SQLException
	 */
	public <T> int[] updateWithListOfModel(List<T> modelsList, String... keys) throws SQLException {
		ModelToSqlConverter modelConverter = new ModelToSqlConverter(modelsList, keys);
		QueryRunner qryRunner = new QueryRunner();
		int[] inserts = null;

		System.out.println("UPDATE " + modelsList.get(0).getClass().getSimpleName().toUpperCase() + " SET "
				+ modelConverter.getSqlString());
		inserts = qryRunner.batch(connection, "UPDATE " + modelsList.get(0).getClass().getSimpleName().toUpperCase()
				+ " SET " + modelConverter.getSqlString(), modelConverter.getMultiValueParams());

		return inserts;
	}

	/**
	 * Update specific row in the Database.<br>
	 * Replacement parameters must match the order of the SQL.
	 * 
	 * @param insertSql
	 * @param params
	 * @return
	 * @throws SQLException
	 */
	public int updateRowInDatabase(String insertSql, Object... params) throws SQLException {
		QueryRunner qryRunner = new QueryRunner();
		int inserts = 1;

		inserts = qryRunner.update(connection, insertSql, params);

		return inserts;
	}

	/**
	 * Gets Column Description in a map. Stores it with column names as keys.
	 * 
	 * @param tableName
	 *            Databse table to retrive info from.
	 * @return HashMap with Column name as key, Column Description as value.
	 * @throws SQLException
	 */
	public HashMap<String, String> getColumnDescriptionForTable(String tableName) throws SQLException {
		HashMap<String, String> columnsMap = new HashMap<>();
		try {
			AS400JDBCDatabaseMetaData metaData = (AS400JDBCDatabaseMetaData) connection.getMetaData();
			AS400JDBCResultSet columnsData = (AS400JDBCResultSet) metaData.getColumns(null, connection.getSchema(),
					tableName, null);
			while (columnsData.next()) {
				columnsMap.put(columnsData.getNString("COLUMN_NAME"), columnsData.getNString("REMARKS"));
			}
		} catch (SQLException e) {
			// TODO Auto-generated catch block
			DbUtils.close(connection);
			e.printStackTrace();
		}
		return columnsMap;
	}

	/**
	 * Delete from table.
	 * 
	 * @return
	 * @throws SQLException
	 */
	public int deleteFromTable(String sql) throws SQLException {
		// TODO Auto-generated method stub
		int rowsDeleted = 0;
		QueryRunner qryRunner = new QueryRunner();
		rowsDeleted = qryRunner.update(connection, sql);
		return rowsDeleted;
	}

	/**
	 * @return Connection
	 */
	public Connection getConnection() {
		return connection;
	}

	/**
	 * Closes Connection
	 */
	public void closeConnection() {
		try {
			DbUtils.close(connection);
		} catch (SQLException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
	}

	/**
	 * Closes the ResultSet and Statement that was used to produce it.
	 * 
	 * @param rs
	 */
	public void closeResultSet(ResultSet rs) {

		if (rs != null)
			try {
				rs.getStatement().close();
				rs.close();
			} catch (SQLException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}
	}

	// class customBeanProcessor extends BeanProcessor{
	//
	// private Class<?> model;
	//
	//
	// public customBeanProcessor(Class<?> model){
	// this.model = model;
	// }
	//
	// @Override
	// protected int[] mapColumnsToProperties(ResultSetMetaData rsmd,
	// PropertyDescriptor[] props) throws
	// SQLException{
	//
	// int cols = rsmd.getColumnCount();
	// int[] columnToProperty = new int[cols + 1];
	// Arrays.fill(columnToProperty, PROPERTY_NOT_FOUND);
	//
	// for(int col = 1; col <= cols; col++){
	// String columnName = rsmd.getColumnLabel(col);
	// if(null == columnName || 0 == columnName.length()){
	// columnName = rsmd.getColumnName(col);
	// }
	// String propertyName = null;
	// if(propertyName == null){
	// propertyName = columnName;
	// }
	// for(int i = 0; i < props.length; i++){
	//
	// if(propertyName.equalsIgnoreCase(props[i].getName())){
	// columnToProperty[col] = i;
	// break;
	// }
	// }
	// }
	//
	// return columnToProperty;
	// }
	// }

}
